//! Vulnerability structures and database traits

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Utc};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;
use std::fmt;

/// Vulnerability information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Vulnerability {
    pub id: String, // CVE ID or custom ID
    pub title: String,
    pub description: String,
    pub severity: VulnerabilitySeverity,
    pub cvss_score: Option<f32>,
    pub cvss_vector: Option<String>,
    pub affected_versions: Vec<String>,
    pub fixed_versions: Vec<String>,
    pub published_date: Option<DateTime<Utc>>,
    pub updated_date: Option<DateTime<Utc>>,
    pub references: Vec<String>,
    pub cwe_ids: Vec<String>,
    pub exploit_available: bool,
    pub patch_available: bool,
}

/// Vulnerability severity levels
#[derive(Debug, Clone, Serialize, Deserialize, PartialEq, Eq, PartialOrd, Ord, Hash)]
pub enum VulnerabilitySeverity {
    None,
    Low,
    Medium,
    High,
    Critical,
}

impl VulnerabilitySeverity {
    /// Convert from CVSS v3 score
    pub fn from_cvss_v3(score: f32) -> Self {
        match score {
            s if s >= 9.0 => Self::Critical,
            s if s >= 7.0 => Self::High,
            s if s >= 4.0 => Self::Medium,
            s if s >= 0.1 => Self::Low,
            _ => Self::None,
        }
    }

    /// Get severity weight for risk scoring
    pub fn weight(&self) -> f32 {
        match self {
            Self::Critical => 10.0,
            Self::High => 7.0,
            Self::Medium => 4.0,
            Self::Low => 1.0,
            Self::None => 0.0,
        }
    }
}

impl fmt::Display for VulnerabilitySeverity {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        match self {
            Self::None => write!(f, "None"),
            Self::Low => write!(f, "Low"),
            Self::Medium => write!(f, "Medium"),
            Self::High => write!(f, "High"),
            Self::Critical => write!(f, "Critical"),
        }
    }
}

/// Vulnerability database trait
#[async_trait]
pub trait VulnerabilityDatabase: Send + Sync {
    /// Check vulnerabilities for a package
    async fn check_package(
        &self,
        package_name: &str,
        version: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>>;

    /// Update the vulnerability database
    async fn update(&mut self) -> Result<UpdateResult>;

    /// Get last update timestamp
    fn last_updated(&self) -> Option<DateTime<Utc>>;

    /// Get database statistics
    fn statistics(&self) -> DatabaseStatistics;

    /// Search vulnerabilities by CVE ID
    async fn get_by_cve(&self, cve_id: &str) -> Result<Option<Vulnerability>>;

    /// Get all vulnerabilities for a package (any version)
    async fn get_all_for_package(
        &self,
        package_name: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>>;
}

/// Database update result
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct UpdateResult {
    pub success: bool,
    pub new_vulnerabilities: usize,
    pub updated_vulnerabilities: usize,
    pub removed_vulnerabilities: usize,
    pub duration_seconds: u64,
    pub errors: Vec<String>,
}

/// Database statistics
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DatabaseStatistics {
    pub total_vulnerabilities: usize,
    pub packages_covered: usize,
    pub last_updated: Option<DateTime<Utc>>,
    pub database_version: String,
    pub vulnerabilities_by_severity: HashMap<VulnerabilitySeverity, usize>,
    pub vulnerabilities_by_year: HashMap<i32, usize>,
}

/// Embedded vulnerability entry for offline database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct EmbeddedVulnerability {
    pub package_name: String,
    pub package_type: String,
    pub vulnerability: Vulnerability,
    pub version_ranges: Vec<VersionRange>,
}

/// Version range specification
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VersionRange {
    pub min_version: Option<String>,
    pub max_version: Option<String>,
    pub include_min: bool,
    pub include_max: bool,
}

impl VersionRange {
    /// Check if a version falls within this range
    pub fn contains(&self, version: &str) -> bool {
        // TODO: Implement proper version comparison
        // This is a simplified implementation
        if let Some(ref min) = self.min_version {
            if version < min.as_str() {
                return false;
            }
        }
        if let Some(ref max) = self.max_version {
            if version > max.as_str() {
                return false;
            }
        }
        true
    }
}
