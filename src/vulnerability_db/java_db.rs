//! Java vulnerability database implementation

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Datelike, Utc};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::core::{
    DatabaseStatistics, UpdateResult, Vulnerability, VulnerabilityDatabase, VulnerabilitySeverity,
};

/// Java vulnerability database
pub struct JavaVulnerabilityDb {
    path: PathBuf,
    cache: HashMap<String, Vec<Vulnerability>>,
    last_updated: Option<DateTime<Utc>>,
}

impl JavaVulnerabilityDb {
    /// Create new Java vulnerability database
    pub fn new() -> Result<Self> {
        let path = dirs::cache_dir()
            .ok_or_else(|| anyhow::anyhow!("Cannot find cache directory"))?
            .join("threatflux")
            .join("java_vulns.db");

        let mut db = Self {
            path,
            cache: HashMap::new(),
            last_updated: None,
        };

        // Load embedded vulnerabilities immediately
        db.load_embedded();

        Ok(db)
    }

    /// Create with custom path
    pub fn with_path(path: &Path) -> Result<Self> {
        let mut db = Self {
            path: path.to_path_buf(),
            cache: HashMap::new(),
            last_updated: None,
        };

        // Load embedded vulnerabilities immediately
        db.load_embedded();

        Ok(db)
    }

    /// Load embedded vulnerabilities
    fn load_embedded(&mut self) {
        // Log4j vulnerability
        self.add_vulnerability("log4j", Vulnerability {
            id: "CVE-2021-44228".to_string(),
            title: "Log4Shell - Remote Code Execution in Log4j".to_string(),
            description: "Apache Log4j2 JNDI features used in configuration, log messages, and parameters do not protect against attacker controlled LDAP and other JNDI related endpoints".to_string(),
            severity: VulnerabilitySeverity::Critical,
            cvss_score: Some(10.0),
            cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H".to_string()),
            affected_versions: vec!["2.0-beta9 to 2.14.1".to_string()],
            fixed_versions: vec!["2.15.0".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2021-12-10T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2021-44228".to_string()],
            cwe_ids: vec!["CWE-502".to_string(), "CWE-400".to_string()],
            exploit_available: true,
            patch_available: true,
        });

        // Spring Framework vulnerability
        self.add_vulnerability("spring-core", Vulnerability {
            id: "CVE-2022-22965".to_string(),
            title: "Spring4Shell - Remote Code Execution in Spring Framework".to_string(),
            description: "A Spring MVC or Spring WebFlux application running on JDK 9+ may be vulnerable to remote code execution (RCE) via data binding".to_string(),
            severity: VulnerabilitySeverity::Critical,
            cvss_score: Some(9.8),
            cvss_vector: Some("CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H".to_string()),
            affected_versions: vec!["< 5.3.18".to_string(), "< 5.2.20".to_string()],
            fixed_versions: vec!["5.3.18".to_string(), "5.2.20".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2022-04-01T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://spring.io/blog/2022/03/31/spring-framework-rce-early-announcement".to_string()],
            cwe_ids: vec!["CWE-94".to_string()],
            exploit_available: true,
            patch_available: true,
        });
    }

    fn add_vulnerability(&mut self, package: &str, vuln: Vulnerability) {
        self.cache
            .entry(package.to_string())
            .or_insert_with(Vec::new)
            .push(vuln);
    }
}

#[async_trait]
impl VulnerabilityDatabase for JavaVulnerabilityDb {
    async fn check_package(
        &self,
        package_name: &str,
        _version: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>> {
        if package_type != "java" {
            return Ok(vec![]);
        }

        Ok(self.cache.get(package_name).cloned().unwrap_or_default())
    }

    async fn update(&mut self) -> Result<UpdateResult> {
        if self.cache.is_empty() {
            self.load_embedded();
        }

        self.last_updated = Some(Utc::now());

        Ok(UpdateResult {
            success: true,
            new_vulnerabilities: self.cache.values().map(|v| v.len()).sum(),
            updated_vulnerabilities: 0,
            removed_vulnerabilities: 0,
            duration_seconds: 0,
            errors: vec![],
        })
    }

    fn last_updated(&self) -> Option<DateTime<Utc>> {
        self.last_updated
    }

    fn statistics(&self) -> DatabaseStatistics {
        let mut stats = DatabaseStatistics {
            total_vulnerabilities: self.cache.values().map(|v| v.len()).sum(),
            packages_covered: self.cache.len(),
            last_updated: self.last_updated,
            database_version: "1.0.0".to_string(),
            vulnerabilities_by_severity: HashMap::new(),
            vulnerabilities_by_year: HashMap::new(),
        };

        for vulns in self.cache.values() {
            for vuln in vulns {
                *stats
                    .vulnerabilities_by_severity
                    .entry(vuln.severity.clone())
                    .or_insert(0) += 1;

                if let Some(date) = &vuln.published_date {
                    *stats
                        .vulnerabilities_by_year
                        .entry(date.year())
                        .or_insert(0) += 1;
                }
            }
        }

        stats
    }

    async fn get_by_cve(&self, cve_id: &str) -> Result<Option<Vulnerability>> {
        for vulns in self.cache.values() {
            for vuln in vulns {
                if vuln.id == cve_id {
                    return Ok(Some(vuln.clone()));
                }
            }
        }
        Ok(None)
    }

    async fn get_all_for_package(
        &self,
        package_name: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>> {
        if package_type != "java" {
            return Ok(vec![]);
        }

        Ok(self.cache.get(package_name).cloned().unwrap_or_default())
    }
}
