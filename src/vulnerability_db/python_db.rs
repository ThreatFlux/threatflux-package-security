//! Python vulnerability database implementation

use anyhow::Result;
use async_trait::async_trait;
use chrono::{DateTime, Datelike, Utc};
use std::collections::HashMap;
use std::path::{Path, PathBuf};

use crate::core::{
    DatabaseStatistics, UpdateResult, Vulnerability, VulnerabilityDatabase, VulnerabilitySeverity,
};

/// Python vulnerability database
pub struct PythonVulnerabilityDb {
    #[allow(dead_code)]
    path: PathBuf,
    cache: HashMap<String, Vec<Vulnerability>>,
    last_updated: Option<DateTime<Utc>>,
}

impl PythonVulnerabilityDb {
    /// Create new Python vulnerability database
    pub fn new() -> Result<Self> {
        let path = dirs::cache_dir()
            .ok_or_else(|| anyhow::anyhow!("Cannot find cache directory"))?
            .join("threatflux")
            .join("python_vulns.db");

        let mut db = Self {
            path,
            cache: HashMap::new(),
            last_updated: None,
        };

        // Load embedded vulnerabilities immediately
        db.load_embedded();

        Ok(db)
    }

    /// Create with custom path
    pub fn with_path(path: &Path) -> Result<Self> {
        let mut db = Self {
            path: path.to_path_buf(),
            cache: HashMap::new(),
            last_updated: None,
        };

        // Load embedded vulnerabilities immediately
        db.load_embedded();

        Ok(db)
    }

    /// Load embedded vulnerabilities
    fn load_embedded(&mut self) {
        // Django vulnerability
        self.add_vulnerability(
            "django",
            Vulnerability {
                id: "CVE-2023-43665".to_string(),
                title: "Django Denial-of-Service vulnerability".to_string(),
                description:
                    "Django Denial-of-Service vulnerability in django.utils.text.Truncator"
                        .to_string(),
                severity: VulnerabilitySeverity::High,
                cvss_score: Some(7.5),
                cvss_vector: None,
                affected_versions: vec!["< 3.2.22".to_string(), "< 4.1.12".to_string()],
                fixed_versions: vec!["3.2.22".to_string(), "4.1.12".to_string()],
                published_date: Some(
                    DateTime::parse_from_rfc3339("2023-10-04T00:00:00Z")
                        .unwrap()
                        .with_timezone(&Utc),
                ),
                updated_date: None,
                references: vec![
                    "https://www.djangoproject.com/weblog/2023/oct/04/security-releases/"
                        .to_string(),
                ],
                cwe_ids: vec!["CWE-400".to_string()],
                exploit_available: false,
                patch_available: true,
            },
        );

        // PyYAML vulnerability
        self.add_vulnerability("pyyaml", Vulnerability {
            id: "CVE-2020-14343".to_string(),
            title: "PyYAML arbitrary code execution".to_string(),
            description: "PyYAML vulnerable to arbitrary code execution when processing untrusted YAML files".to_string(),
            severity: VulnerabilitySeverity::Critical,
            cvss_score: Some(9.8),
            cvss_vector: None,
            affected_versions: vec!["< 5.4".to_string()],
            fixed_versions: vec!["5.4".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2020-07-21T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://github.com/yaml/pyyaml/wiki/PyYAML-yaml.load(input)-Deprecation".to_string()],
            cwe_ids: vec!["CWE-502".to_string()],
            exploit_available: true,
            patch_available: true,
        });

        // Flask (security header vulnerability)
        self.add_vulnerability("flask", Vulnerability {
            id: "CVE-2018-1000656".to_string(),
            title: "Flask denial of service vulnerability".to_string(),
            description: "Flask before 1.0 is vulnerable to denial of service via memory exhaustion in the development server".to_string(),
            severity: VulnerabilitySeverity::High,
            cvss_score: Some(7.5),
            cvss_vector: None,
            affected_versions: vec!["< 1.0".to_string()],
            fixed_versions: vec!["1.0".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2018-10-26T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2018-1000656".to_string()],
            cwe_ids: vec!["CWE-400".to_string()],
            exploit_available: false,
            patch_available: true,
        });

        // requests (proxy header leakage)
        self.add_vulnerability("requests", Vulnerability {
            id: "CVE-2018-18074".to_string(),
            title: "Requests Credential Disclosure vulnerability".to_string(),
            description: "The Requests package through 2.19.1 for Python allows local users to discover credentials by reading a process list".to_string(),
            severity: VulnerabilitySeverity::Medium,
            cvss_score: Some(5.5),
            cvss_vector: None,
            affected_versions: vec!["< 2.20.0".to_string()],
            fixed_versions: vec!["2.20.0".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2018-10-09T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2018-18074".to_string()],
            cwe_ids: vec!["CWE-200".to_string()],
            exploit_available: false,
            patch_available: true,
        });

        // Pillow (uncontrolled resource consumption)
        self.add_vulnerability("pillow", Vulnerability {
            id: "CVE-2021-25287".to_string(),
            title: "Pillow out-of-bounds read vulnerability".to_string(),
            description: "An issue was discovered in Pillow before 8.2.0. There is an out-of-bounds read in J2kDecode".to_string(),
            severity: VulnerabilitySeverity::High,
            cvss_score: Some(9.1),
            cvss_vector: None,
            affected_versions: vec!["< 8.2.0".to_string()],
            fixed_versions: vec!["8.2.0".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2021-05-25T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2021-25287".to_string()],
            cwe_ids: vec!["CWE-125".to_string()],
            exploit_available: false,
            patch_available: true,
        });

        // NumPy (NULL pointer dereference)
        self.add_vulnerability("numpy", Vulnerability {
            id: "CVE-2021-33430".to_string(),
            title: "NumPy buffer overflow vulnerability".to_string(),
            description: "A Buffer Overflow vulnerability exists in NumPy 1.9.x in the PyArray_NewFromDescr_int function".to_string(),
            severity: VulnerabilitySeverity::High,
            cvss_score: Some(7.8),
            cvss_vector: None,
            affected_versions: vec!["< 1.21.0".to_string()],
            fixed_versions: vec!["1.21.0".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2021-05-19T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2021-33430".to_string()],
            cwe_ids: vec!["CWE-120".to_string()],
            exploit_available: false,
            patch_available: true,
        });

        // urllib3 (cookie header leakage)
        self.add_vulnerability("urllib3", Vulnerability {
            id: "CVE-2021-33503".to_string(),
            title: "urllib3 Improper Certificate Validation vulnerability".to_string(),
            description: "An issue was discovered in urllib3 before 1.26.5. When provided with a URL containing many @ characters in the authority component, the authority regular expression exhibits catastrophic backtracking".to_string(),
            severity: VulnerabilitySeverity::High,
            cvss_score: Some(7.5),
            cvss_vector: None,
            affected_versions: vec!["< 1.26.5".to_string()],
            fixed_versions: vec!["1.26.5".to_string()],
            published_date: Some(DateTime::parse_from_rfc3339("2021-06-29T00:00:00Z").unwrap().with_timezone(&Utc)),
            updated_date: None,
            references: vec!["https://nvd.nist.gov/vuln/detail/CVE-2021-33503".to_string()],
            cwe_ids: vec!["CWE-1333".to_string()],
            exploit_available: false,
            patch_available: true,
        });
    }

    fn add_vulnerability(&mut self, package: &str, vuln: Vulnerability) {
        self.cache
            .entry(package.to_string())
            .or_default()
            .push(vuln);
    }
}

#[async_trait]
impl VulnerabilityDatabase for PythonVulnerabilityDb {
    async fn check_package(
        &self,
        package_name: &str,
        _version: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>> {
        if package_type != "python" {
            return Ok(vec![]);
        }

        Ok(self.cache.get(package_name).cloned().unwrap_or_default())
    }

    async fn update(&mut self) -> Result<UpdateResult> {
        if self.cache.is_empty() {
            self.load_embedded();
        }

        self.last_updated = Some(Utc::now());

        Ok(UpdateResult {
            success: true,
            new_vulnerabilities: self.cache.values().map(|v| v.len()).sum(),
            updated_vulnerabilities: 0,
            removed_vulnerabilities: 0,
            duration_seconds: 0,
            errors: vec![],
        })
    }

    fn last_updated(&self) -> Option<DateTime<Utc>> {
        self.last_updated
    }

    fn statistics(&self) -> DatabaseStatistics {
        let mut stats = DatabaseStatistics {
            total_vulnerabilities: self.cache.values().map(|v| v.len()).sum(),
            packages_covered: self.cache.len(),
            last_updated: self.last_updated,
            database_version: "1.0.0".to_string(),
            vulnerabilities_by_severity: HashMap::new(),
            vulnerabilities_by_year: HashMap::new(),
        };

        for vulns in self.cache.values() {
            for vuln in vulns {
                *stats
                    .vulnerabilities_by_severity
                    .entry(vuln.severity.clone())
                    .or_insert(0) += 1;

                if let Some(date) = &vuln.published_date {
                    *stats
                        .vulnerabilities_by_year
                        .entry(date.year())
                        .or_insert(0) += 1;
                }
            }
        }

        stats
    }

    async fn get_by_cve(&self, cve_id: &str) -> Result<Option<Vulnerability>> {
        for vulns in self.cache.values() {
            for vuln in vulns {
                if vuln.id == cve_id {
                    return Ok(Some(vuln.clone()));
                }
            }
        }
        Ok(None)
    }

    async fn get_all_for_package(
        &self,
        package_name: &str,
        package_type: &str,
    ) -> Result<Vec<Vulnerability>> {
        if package_type != "python" {
            return Ok(vec![]);
        }

        Ok(self.cache.get(package_name).cloned().unwrap_or_default())
    }
}
